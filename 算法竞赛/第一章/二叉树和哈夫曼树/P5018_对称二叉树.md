---
title: P5018 [NOIP2018 普及组] 对称二叉树 - 洛谷 | 计算机科学教育新生态
source: https://www.luogu.com.cn/problem/P5018
tags:
  - 算法题/数据结构/树
  - 算法题/题型/序列
  - 算法题/题型/DFS
---

## 题目背景

NOIP2018 普及组 T4

## 题目描述

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：

1. 二叉树；
2. 将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。

## 输入格式

第一行一个正整数 $n$，表示给定的树的节点的数目，规定节点编号 $1 \sim n$，其中节点 $1$ 是树根。

第二行 $n$ 个正整数，用一个空格分隔，第 $i$ 个正整数 $v_i$ 代表节点 $i$ 的权值。

接下来 $n$ 行，每行两个正整数 $l_i, r_i$，分别表示节点 $i$ 的左右孩子的编号。如果不存在左 / 右孩子，则以 $-1$ 表示。两个数之间用一个空格隔开。

## 输出格式

输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。

## 输入输出样例

**输入 #1**

```
2 
1 3 
2 -1 
-1 -1 
```

**输出 #1**
```
1
```

**输入 #2**

```
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8
```

**输出 #2**
```
3
```

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/4lfen5aa.png)  
最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/vhzzc587.png)

最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。

**数据规模与约定**

共 $25$ 个测试点。

$v_i ≤ 1000$。

- 测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。
- 测试点 $4 \sim 8, n ≤ 10$。
- 测试点 $9 \sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。
- 测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。
- 测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。
- 测试点 $21 \sim 25, n ≤ 10^6$。

本题约定：

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。

树的深度：树中节点的最大层次称为树的深度。

满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。

![](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。

![](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

## 题解

在此之前我在[《数据结构教程》](https://github.com/AK47are/ds-tutorial-exercises/blob/main/docs/books/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B%E4%B9%A0%E9%A2%98%EF%BC%88%E7%AC%AC%E5%85%AD%E7%89%88%EF%BC%89_%E5%90%AB%E7%9B%AE%E5%BD%95.pdf)在树的那一章遇到过一道序列化的题，还有一道判断子树树形结构是否相同的题，我们也许可以参考。

> [!note]
> 序列化与前序遍历唯一区别在于序列化还要显示空结点，我们这里使用 "-1" 表示空结点。

我们先考虑无权对称二叉树，我们从它的序列化考虑，通过序列化我们就可以只通过一个序列就可构造树。我们观察会发现**如果树对称的，那么其左右子树的中序序列化刚好相反了**。如果树是对称的那么一定有左子树的左子树中序序列化 + 左子树根结点 + 右子树的右子树中序序列化 = 右子树的右子树中序序列化 + 右子树根结点 + 右子树的左子树序列化。

那么我们就有了一个很简单的判断树对称的方法，就是将其中序序列化截断然后颠倒，判断是否相等。还有个问题在于给你一段序列如何判断其根结点，因为空结点都是叶子 结点，左右子树一定满足 子树结点（非空） = 子树空结点 - 1 ，因此当满足这个条件时，它的下一个结点就是根结点。

对于权值只需比较是否相等即可。

