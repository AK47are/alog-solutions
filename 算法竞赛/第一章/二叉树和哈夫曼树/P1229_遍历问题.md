---
title: P1229 遍历问题 - 洛谷 | 计算机科学教育新生态
source: https://www.luogu.com.cn/problem/P1229
tags:
  - 算法题/数据结构/树
  - 算法题/题型/序列
---

## 题目描述

我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：

![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)

所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。

## 输入格式

共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。

保证至少存在一棵二叉树满足给出的信息，$s _ 1, s _ 2$ 中只含小写字母，且在某个字符串中不存在相同的字母。

## 输出格式

输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。

## 输入输出样例

**输入 #1**

```
abc                           
cba
```

**输出 #1**

```
4
```

## 题解

必须知道只有前序和后序序列时，哪种结点无法确定其子节点的左右情况。我们知道：
- 前序序列 = 根结点 + 左子树前序序列 + 右子树前序序列
- 后序序列 = 左子树后序序列 + 右子树后序序列 + 根结点。

如果左子树前序序列非空，那么我们可以通过前序序列得到根结点的左子结点，同理右子树后序序列非空，我们可以通过后序序列得到根结点的右子节点。我们可以等价认为非空条件为左右子树有结点，因此我们可以知道**如果根结点的左右子树都非空，那么其左右结点是确定的**。

我们再考虑左子树为空的情况，如果左子树为空，那么前序序列中根结点的右侧结点一定会和后序序列中根结点的左侧结点相同。同理右子树为空，那么也会相同。该结论互为充分必要条件。

如果出现了前序序列中根结点的右侧结点和后序序列中根结点的左侧结点相同的情况，这代表有子树是空的，但我们无法判断是哪个子树。这就出现了两种可能。

最后我们可得出结论：**如果前序序列中根结点的右侧结点和后序序列中根结点的左侧结点相同，那么无法判断该相同子节点在根结点上的位置。**

本身子树的前后序和根结点的前后序是嵌套的，因此我们只要遍历一下，让每个结点充当一遍根结点，判断它旁边的结点是否相同即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  string s1, s2;
  cin >> s1 >> s2;
  int ans = 1;
  for (int i = 0; i < s1.size() - 1; ++i) {
    if (s1[i + 1] == s2[s2.find(s1[i]) - 1]) ans *= 2;
  }
  cout << ans << "\n";
}

```